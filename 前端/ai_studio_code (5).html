<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº§çº¿èŠ‚æ‹è„‰æè®°å½•ä»ª - è‡ªåŠ¨åˆ·æ–°ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.staticfile.net/vue/3.3.4/vue.global.prod.min.js"></script>
    <!-- å¼•å…¥ ECharts -->
    <script src="https://cdn.staticfile.net/echarts/5.4.3/echarts.min.js"></script>
    <script src="https://cdn.staticfile.net/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { background-color: #f8fafc; font-family: 'Inter', 'Microsoft YaHei', sans-serif; }
        .glass-panel { background: rgba(255, 255, 255, 1); border: 1px solid #e2e8f0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); }
        [v-cloak] { display: none; }
        /* é—ªçƒåŠ¨ç”»ï¼Œç”¨äºæŒ‡ç¤ºæ•°æ®æ›´æ–° */
        .pulse-dot { animation: pulse-green 2s infinite; }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
    </style>
</head>
<body>

<div id="app" v-cloak class="min-h-screen flex flex-col">

    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <header class="bg-white border-b border-gray-200 sticky top-0 z-20">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center gap-3">
                    <div class="bg-blue-600 p-2 rounded-lg text-white shadow-md">
                        <i data-lucide="activity" class="w-6 h-6"></i>
                    </div>
                    <div>
                        <h1 class="text-xl font-bold text-gray-900 tracking-tight">Bçº¿èŠ‚æ‹è®°å½•ä»ª</h1>
                        <div class="flex items-center gap-2">
                            <span class="flex h-2 w-2 relative">
                                <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                                <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                            </span>
                            <p class="text-xs text-green-600 font-medium">
                                ç³»ç»ŸçŠ¶æ€: å®æ—¶ç›‘æ§ä¸­ (2s/æ¬¡)
                            </p>
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <nav class="flex bg-gray-100 p-1 rounded-lg mr-4">
                        <button @click="currentView = 'monitor'" 
                            :class="[currentView === 'monitor' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-500', 'px-4 py-1.5 text-sm font-medium rounded-md transition-all']">
                            ğŸ–¥ï¸ å®æ—¶çœ‹æ¿
                        </button>
                        <button @click="currentView = 'report'" 
                            :class="[currentView === 'report' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-500', 'px-4 py-1.5 text-sm font-medium rounded-md transition-all']">
                            ğŸ“‹ æ•°æ®å®¡è®¡
                        </button>
                    </nav>
                    
                    <div class="text-xs text-gray-400 tabular-nums">
                        ä¸Šæ¬¡æ›´æ–°: {{ lastUpdateTime || '...' }}
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- é”™è¯¯æç¤º -->
    <div v-if="errorMsg" class="bg-red-50 border-l-4 border-red-500 p-4 mx-auto max-w-7xl mt-4 transition-all">
        <div class="flex">
            <i data-lucide="alert-triangle" class="h-5 w-5 text-red-400 mr-3"></i>
            <p class="text-sm text-red-700">{{ errorMsg }}</p>
        </div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <main class="flex-1 max-w-7xl w-full mx-auto p-6">
        
        <!-- === è§†å›¾ 1: å®æ—¶çœ‹æ¿ === -->
        <div v-show="currentView === 'monitor'" class="space-y-6">
            <div v-if="stations.length === 0" class="text-center py-12 text-gray-400">
                <i data-lucide="loader" class="w-8 h-8 mx-auto animate-spin mb-2"></i>
                <p>æ­£åœ¨ç­‰å¾…æ•°æ®æ¥å…¥...</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <div v-for="(station, index) in stations" :key="station.id" 
                     class="glass-panel rounded-xl p-5 border-t-4 transition-all duration-500"
                     :class="getBorderColor(station.lastInterval)">
                    
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h3 class="font-bold text-gray-800 text-lg truncate pr-2" :title="station.name">{{ station.name }}</h3>
                            <span class="text-xs text-gray-400 font-mono">ID: {{ station.id }}</span>
                        </div>
                        <div class="h-3 w-3 rounded-full transition-all duration-200"
                             :class="[station.lastInterval ? 'bg-green-500 pulse-dot' : 'bg-slate-200']">
                        </div>
                    </div>

                    <div class="flex items-baseline gap-2 mb-4">
                        <span class="text-5xl font-bold font-mono tracking-tighter" :class="getTextColor(station.lastInterval)">
                            {{ station.lastInterval ? station.lastInterval.toFixed(1) : '--' }}
                        </span>
                        <span class="text-sm text-gray-500 font-medium">ç§’/ä»¶</span>
                    </div>

                    <!-- å°è¶‹åŠ¿å›¾ -->
                    <div class="h-16 w-full bg-slate-50 rounded-lg border border-slate-100 overflow-hidden relative mb-3">
                        <div :id="'sparkline-' + index" class="w-full h-full"></div>
                    </div>

                    <div class="flex justify-between text-xs text-gray-500 pt-3 border-t border-gray-100">
                        <div class="font-mono">{{ formatTimeOnly(station.lastTimeStr) }}</div>
                        <div>ç´¯è®¡: <span class="font-mono font-bold text-gray-700">{{ station.recordCount }}</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- === è§†å›¾ 2: æ•°æ®æŠ¥è¡¨ === -->
        <div v-show="currentView === 'report'" class="h-[calc(100vh-9rem)] flex flex-col lg:flex-row gap-6">
            
            <!-- å·¦ä¾§è¡¨æ ¼ -->
            <div class="lg:w-1/2 flex flex-col glass-panel rounded-xl overflow-hidden bg-white">
                <div class="px-5 py-4 border-b border-gray-100 flex justify-between items-center bg-gray-50/50">
                    <h3 class="font-bold text-gray-700 flex items-center gap-2">
                        <i data-lucide="table" class="w-4 h-4 text-blue-500"></i> å®æ—¶è®°å½•æµ
                    </h3>
                    <button @click="exportExcel" class="text-xs bg-white border border-gray-300 px-3 py-1.5 rounded hover:bg-gray-50 transition flex items-center gap-1">
                        <i data-lucide="download" class="w-3 h-3"></i> å¯¼å‡º
                    </button>
                </div>
                
                <div class="flex-1 overflow-auto scrollbar-thin relative">
                    <table class="w-full text-sm text-left">
                        <thead class="text-xs text-gray-500 uppercase bg-gray-50 sticky top-0 z-10 shadow-sm">
                            <tr>
                                <th class="px-4 py-3">å·¥ä½</th>
                                <th class="px-4 py-3">è§¦å‘æ—¶é—´</th>
                                <th class="px-4 py-3 text-right">èŠ‚æ‹(ç§’)</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-100 bg-white">
                            <tr v-for="row in logs" :key="row.uniqueKey" class="hover:bg-blue-50/50 transition-colors">
                                <td class="px-4 py-2 font-medium text-gray-700 truncate max-w-[120px]" :title="row.point">{{ row.point }}</td>
                                <td class="px-4 py-2 text-gray-500 tabular-nums text-xs">{{ row.current }}</td>
                                <td class="px-4 py-2 text-right font-bold tabular-nums font-mono" :class="getTextColor(row.rawInterval)">
                                    {{ row.interval }}
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- å³ä¾§å¤§å›¾ -->
            <div class="lg:w-1/2 flex flex-col gap-6">
                <div class="glass-panel rounded-xl flex flex-col flex-1 overflow-hidden bg-white">
                    <div class="px-5 py-4 border-b border-gray-100 bg-gray-50/50 flex justify-between items-center z-10">
                        <h3 class="font-bold text-gray-700 flex items-center gap-2">
                            <i data-lucide="trending-up" class="w-4 h-4 text-blue-500"></i> ç¨³å®šæ€§è¶‹åŠ¿
                        </h3>
                        <select v-model="selectedChartStation" class="text-sm border-gray-300 border rounded px-2 py-1 bg-white outline-none">
                            <option value="all">âš¡ æ‰€æœ‰å·¥ä½</option>
                            <option v-for="s in stations" :value="s.name">ğŸ“ {{ s.name }}</option>
                        </select>
                    </div>
                    <div class="flex-1 w-full min-h-[300px] p-2 bg-white relative">
                        <div id="main-chart" class="w-full h-full"></div>
                    </div>
                </div>
                
                <!-- ç»Ÿè®¡ -->
                <div class="glass-panel rounded-xl p-5 bg-white">
                     <div class="grid grid-cols-3 gap-4 text-center">
                        <div>
                            <div class="text-xs text-gray-400 uppercase mb-1">å¹³å‡</div>
                            <div class="text-xl font-bold text-blue-600 font-mono">{{ chartStats.avg }}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400 uppercase mb-1">æœ€å¿«</div>
                            <div class="text-xl font-bold text-emerald-600 font-mono">{{ chartStats.min }}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400 uppercase mb-1">æœ€æ…¢</div>
                            <div class="text-xl font-bold text-rose-600 font-mono">{{ chartStats.max }}</div>
                        </div>
                     </div>
                </div>
            </div>
        </div>

    </main>
</div>

<script>
    const { createApp, ref, computed, onMounted, onUnmounted, watch, nextTick } = Vue;

    createApp({
        setup() {
            // === é…ç½® ===
            const API_URL = 'http://127.0.0.1:1880/api/takt-logs'; // è¯·ç¡®ä¿åç«¯åœ°å€æ­£ç¡®
            const REFRESH_RATE = 2000; // 2ç§’åˆ·æ–°ä¸€æ¬¡
            const TARGET_TIME = 10.0; 
            
            // === çŠ¶æ€ ===
            const currentView = ref('monitor'); 
            const selectedChartStation = ref('all');
            const errorMsg = ref('');
            const lastUpdateTime = ref('');
            
            const stations = ref([]); // åŠ¨æ€ç”Ÿæˆ
            const logs = ref([]);     // åŸå§‹æ—¥å¿—
            
            let timer = null;
            let mainChart = null;
            let sparklines = [];

            // === æ ¸å¿ƒæ•°æ®é€»è¾‘ ===
            const fetchData = async () => {
                try {
                    const response = await fetch(API_URL);
                    if (!response.ok) throw new Error('API å“åº”å¼‚å¸¸');
                    const data = await response.json();
                    
                    processData(data);
                    errorMsg.value = ''; // æ¸…é™¤é”™è¯¯
                    lastUpdateTime.value = new Date().toLocaleTimeString();
                    
                    // åˆ·æ–°å›¾è¡¨
                    nextTick(() => {
                        updateSparklines();
                        if (currentView.value === 'report') updateMainChart();
                    });

                } catch (err) {
                    console.error("Fetch error:", err);
                    errorMsg.value = `æ•°æ®è¿æ¥ä¸­æ–­: ${err.message} (æ­£åœ¨å°è¯•é‡è¿...)`;
                }
            };

            const processData = (rawData) => {
                // 1. æå–æ‰€æœ‰ä¸é‡å¤çš„å·¥ä½åç§°
                const uniqueStations = {};
                
                // 2. å¤„ç†æ—¥å¿—
                // å‡è®¾ rawData å·²ç»åŒ…å«äº† station_name, current_time, interval_sec
                // ä¸ºäº†é¿å… key å†²çªï¼Œæˆ‘ä»¬ç»™æ¯æ¡ log ä¸€ä¸ªä¸´æ—¶ key
                const processedLogs = rawData.map((item, idx) => {
                    // æ”¶é›†å·¥ä½ä¿¡æ¯
                    const sName = item.station_name || item.station_id || 'æœªçŸ¥å·¥ä½';
                    const sId = item.station_id || ('S-' + idx);
                    
                    if (!uniqueStations[sName]) {
                        uniqueStations[sName] = {
                            id: sId,
                            name: sName,
                            lastTimeStr: null,
                            lastInterval: null,
                            recordCount: 0,
                            history: []
                        };
                    }
                    
                    // ç»Ÿè®¡
                    uniqueStations[sName].recordCount++;
                    if (item.interval_sec !== null) {
                        uniqueStations[sName].history.push(Number(item.interval_sec));
                    }

                    // è®°å½•æœ€æ–°çŠ¶æ€ (å‡è®¾æ•°æ®å¯èƒ½ä¸æ˜¯ä¸¥æ ¼æ’åºï¼Œæ¯”è¾ƒä¸€ä¸‹æ—¶é—´)
                    // å¦‚æœ API ä¿è¯æ˜¯æŒ‰æ—¶é—´å€’åº/æ­£åºï¼Œå¯ä»¥ç›´æ¥å–
                    // è¿™é‡Œç®€å•å¤„ç†ï¼šå–éå†åˆ°çš„æœ€åä¸€ä¸ªæœ‰æ•ˆå€¼ä½œä¸ºâ€œæœ€æ–°â€
                    uniqueStations[sName].lastTimeStr = item.current_time;
                    uniqueStations[sName].lastInterval = item.interval_sec ? Number(item.interval_sec) : null;

                    return {
                        uniqueKey: item.id || idx,
                        point: sName,
                        current: item.current_time,
                        interval: item.interval_sec ? Number(item.interval_sec).toFixed(1) : '--',
                        rawInterval: item.interval_sec ? Number(item.interval_sec) : 0,
                        timestamp: new Date(item.current_time).getTime() // ç”¨äºå›¾è¡¨æ—¶é—´è½´
                    };
                });

                // 3. æ›´æ–° Vue çŠ¶æ€
                // è¡¨æ ¼ï¼šæŒ‰æ—¶é—´å€’åº (æœ€æ–°çš„åœ¨ä¸Šé¢)
                logs.value = processedLogs.sort((a, b) => b.timestamp - a.timestamp);
                
                // å·¥ä½åˆ—è¡¨ï¼šè½¬ä¸ºæ•°ç»„
                const stationList = Object.values(uniqueStations);
                // ä¿æŒ Sparkline æ•°ç»„é•¿åº¦é€‚ä¸­
                stationList.forEach(s => {
                    if(s.history.length > 20) s.history = s.history.slice(-20);
                });
                
                // å¦‚æœå·¥ä½æ•°é‡å˜åŒ–ï¼Œå¯èƒ½éœ€è¦é‡ç½® sparklines å®ä¾‹
                if (stationList.length !== stations.value.length) {
                    stations.value = stationList;
                    nextTick(initSparklines);
                } else {
                    stations.value = stationList;
                }
            };

            // === ECharts å›¾è¡¨é€»è¾‘ (å…³é”®ä¿®å¤) ===

            const updateMainChart = () => {
                const dom = document.getElementById('main-chart');
                if (!dom) return;
                if (!mainChart) mainChart = echarts.init(dom);

                // å‡†å¤‡ Series æ•°æ®
                const seriesData = [];
                const legendData = [];
                
                // æ‰¾å‡ºè¦æ˜¾ç¤ºçš„å·¥ä½
                const targetStations = selectedChartStation.value === 'all' 
                    ? stations.value 
                    : stations.value.filter(s => s.name === selectedChartStation.value);

                targetStations.forEach(station => {
                    // ä» logs é‡Œç­›é€‰è¯¥å·¥ä½çš„æ‰€æœ‰æ•°æ®
                    // æ•°æ®æ ¼å¼å¿…é¡»æ˜¯: [ [timestamp, value], [timestamp, value] ]
                    // è¿™æ · ECharts Time Axis æ‰èƒ½æ­£ç¡®å¯¹é½ä¸åŒå·¥ä½çš„æ—¶é—´ç‚¹
                    const stationLogs = logs.value
                        .filter(l => l.point === station.name && l.rawInterval > 0)
                        .sort((a, b) => a.timestamp - b.timestamp); // å¿…é¡»æŒ‰æ—¶é—´æ­£åº

                    const dataPoints = stationLogs.map(l => [l.current, l.rawInterval]);

                    if (dataPoints.length > 0) {
                        legendData.push(station.name);
                        seriesData.push({
                            name: station.name,
                            type: 'line',
                            symbol: 'circle',
                            symbolSize: 6,
                            smooth: true,
                            connectNulls: false, // æ—¶é—´è½´å¦‚æœä¸è¿ç»­ï¼Œæ˜¯å¦è¿æ¥ï¼Ÿé€šå¸¸ false æ›´çœŸå®
                            data: dataPoints,
                            markLine: selectedChartStation.value !== 'all' ? {
                                data: [{ yAxis: TARGET_TIME, label: { formatter: 'ç›®æ ‡' } }]
                            } : undefined
                        });
                    }
                });

                const option = {
                    tooltip: { 
                        trigger: 'axis',
                        axisPointer: { type: 'cross' }
                    },
                    legend: { bottom: 0, data: legendData },
                    grid: { top: 30, bottom: 60, left: 50, right: 30 },
                    xAxis: { 
                        type: 'time', // <--- å…³é”®ä¿®æ”¹ï¼šä½¿ç”¨æ—¶é—´è½´
                        axisLabel: { formatter: '{HH}:{mm}:{ss}' },
                        splitLine: { show: false }
                    },
                    yAxis: { 
                        type: 'value', 
                        name: 'ç§’ (s)',
                        min: 0, // èŠ‚æ‹ä¸ä¼šå°äº0
                        splitLine: { lineStyle: { type: 'dashed' } }
                    },
                    series: seriesData
                };

                mainChart.setOption(option, { notMerge: true }); // notMerge ç¡®ä¿æ—§æ•°æ®è¢«æ¸…é™¤
            };

            const initSparklines = () => {
                // æ¸…ç†æ—§å®ä¾‹
                sparklines.forEach(i => i && i.dispose());
                sparklines = [];
                
                stations.value.forEach((s, i) => {
                    const dom = document.getElementById('sparkline-' + i);
                    if(dom) {
                        const chart = echarts.init(dom);
                        sparklines[i] = chart;
                        chart.setOption({
                            grid: { top: 2, bottom: 2, left: 0, right: 0 },
                            xAxis: { type: 'category', show: false },
                            yAxis: { type: 'value', show: false, min: 0 },
                            series: [{
                                type: 'line', 
                                data: [], 
                                smooth: true, 
                                showSymbol: false,
                                areaStyle: { opacity: 0.2, color: '#3b82f6' },
                                lineStyle: { color: '#3b82f6', width: 1.5 }
                            }]
                        });
                    }
                });
                updateSparklines();
            };

            const updateSparklines = () => {
                stations.value.forEach((s, i) => {
                    if(sparklines[i]) {
                        sparklines[i].setOption({ series: [{ data: s.history }] });
                        sparklines[i].resize();
                    }
                });
            };

            // === è¾…åŠ© ===
            const getBorderColor = (val) => !val ? 'border-gray-200' : (val > TARGET_TIME * 1.2 ? 'border-red-400' : 'border-green-500');
            const getTextColor = (val) => {
                if (!val) return 'text-gray-300';
                return val > TARGET_TIME * 1.2 ? 'text-red-600' : 'text-gray-800';
            };
            const formatTimeOnly = (str) => str ? str.split(' ')[1] : '--:--';
            
            const exportExcel = () => {
                const ws = XLSX.utils.json_to_sheet(logs.value);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Log");
                XLSX.writeFile(wb, `Data_${Date.now()}.xlsx`);
            };

            const chartStats = computed(() => {
                const target = selectedChartStation.value;
                const validData = logs.value
                    .filter(r => r.rawInterval > 0 && (target === 'all' || r.point === target))
                    .map(r => r.rawInterval);
                if(validData.length === 0) return { avg: '-', min: '-', max: '-' };
                
                const sum = validData.reduce((a,b)=>a+b,0);
                return {
                    avg: (sum / validData.length).toFixed(1) + 's',
                    min: Math.min(...validData).toFixed(1) + 's',
                    max: Math.max(...validData).toFixed(1) + 's'
                };
            });

            // === ç”Ÿå‘½å‘¨æœŸ ===
            onMounted(() => {
                lucide.createIcons();
                fetchData(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
                timer = setInterval(fetchData, REFRESH_RATE); // å¼€å¯è‡ªåŠ¨åˆ·æ–°
                
                window.addEventListener('resize', () => {
                    mainChart && mainChart.resize();
                    sparklines.forEach(c => c && c.resize());
                });
            });

            onUnmounted(() => {
                if(timer) clearInterval(timer);
            });

            watch(currentView, (val) => {
                if(val === 'report') nextTick(updateMainChart);
            });
            watch(selectedChartStation, updateMainChart);

            return {
                currentView, stations, logs, selectedChartStation, chartStats, errorMsg, lastUpdateTime,
                getBorderColor, getTextColor, formatTimeOnly, exportExcel
            };
        }
    }).mount('#app');
</script>
</body>
</html>